package Flex;
import java_cup.runtime.*; 

parser code {:
    public static int errors = 0;
    public static kcScanner s;
    public static JTextArea compilerOutput;

    public parser(java.io.Reader input, JTextArea text) {
        super(s=new kcScanner(input));
        compilerOutput = text;
    }

    public void report_error(String message, Object info) {

        if (info instanceof java_cup.runtime.Symbol){
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol)info);
            errors++;
            compilerOutput.append("  " + errors + "==> " +" " + message
                    + "\n\t\tline: "+ (s.left+1) + ", column: "+(s.right+1) + "\n");
        } else {
            StringBuffer m = new StringBuffer("Error ");
            if (info instanceof java_cup.runtime.Symbol) {
                m.append("(" + info.toString() + ")");
            }
            m.append(" : " + message + "\n");
            compilerOutput.append(m.toString());
        }

    }
    public void report_fatal_error(String message, Object info) {
        try{
            report_error(message, info);
        }catch(Exception e){
           compilerOutput.append("Fatal Syntax Error GG WP");
        }
        
    }
:};


/* Variables */
terminal INTEGER, BOOLEAN, DOUBLE, CHAR, STRING, VOID;

/* Iterations Structures */
terminal FOR, WHILE;

/* Decision Structures */
terminal IF, ELSE, SWITCH, CASE, DEFAULT, BREAK, CONTINUE;

/* Functions */
terminal MAIN, RETURN;

/* I/O */
terminal PRINT, SCAN;

/* Others */
terminal COMMA, END, COLON;

/* Arithmetic operators */
terminal ADD, MIN, MUL, DIV;

/* Grouping symbols */
terminal OPAR, CPAR, OCBRA, CCBRA;

/* Arithmetic operators */
terminal GREATEREQ, LESSEQ, GREATER, LESS;

/* Logic operators */
terminal OR, AND, NEQU, EQU;

/* Assignment operator */
terminal ASSIGN;

/* Values */
terminal String ID;
terminal Integer INT;
terminal Double DOUBLEVALUE;
terminal Character CHARCONTENT;
terminal String STRINGCONTENT;
terminal Boolean TRUE;
terminal Boolean FALSE;


/* Non terminals */
non terminal main_function_declaration;
non terminal external_declaration;
non terminal main_function;
non terminal function_definition;
non terminal jump_statement;
non terminal iteration_statement;
non terminal selection_statement;
non terminal expression_statement;
non terminal statement_list;
non terminal declaration_list;
non terminal compound_statement;
non terminal labeled_statement;
non terminal statement;
non terminal identifier_list;
non terminal parameter_list;
non terminal main_declarator;
non terminal type_specifier;
non terminal variable_type_specifier;
non terminal declaration;
non terminal assignment_expression;
non terminal conditional_expression;
non terminal equality_expression;
non terminal relational_expression;
non terminal additive_expression;
non terminal multiplicative_expression;
non terminal basic_expression;
non terminal primary_expression;


/* Precedences */
precedence left ADD, MIN;
precedence left MUL, DIV;
precedence nonassoc ELSE;

/*Main Function Declaration*/
main_function_declaration ::= declaration main_function_declaration       							{:compilerOutput.append("Main_Function_Declaration -> Declaration Main_Function_Declaration\n");:}
    |  main_function external_declaration                             								{:compilerOutput.append("Main_Function_Declaration -> Main_Function External_Declaration\n");:}
    ;

/*External Function Declarations*/
external_declaration ::= function_definition external_declaration       							{:compilerOutput.append("External_Declaration -> Function_Definition External_Declaration\n");:}
    |                                                                 								{:compilerOutput.append("External_Declaration -> Lambda\n");:} 
	;

/*Main Function*/
main_function ::= type_specifier main_declarator compound_statement          						{:compilerOutput.append("Main_Function -> Type_Specifier Main_Declarator Compound_Statement\n");:}  
    | error:e                                                                                 		{: parser.report_error("main function",e); :}            
    ;

/*Function Declaration*/
function_definition ::= type_specifier ID:id OPAR CPAR compound_statement               			{:compilerOutput.append("Function_Definition -> type_specifier " +id+ "() compound_statement\n");:}
	| type_specifier ID:id OPAR parameter_list CPAR compound_statement 								{:compilerOutput.append("Function_Definition -> type_specifier " +id+ "( parameter_list ) compound_statement\n");:}
	| error:e                                                                                       {:parser.report_error("function definition",e); :}    
    ;

/*Jump Statements*/
jump_statement ::=   CONTINUE END                                     								{:compilerOutput.append("Jump_Statement -> secondChance;\n");:}
	| BREAK END                                                       								{:compilerOutput.append("Jump_Statement -> ragnarok;\n");:}
	| RETURN END                                                      								{:compilerOutput.append("Jump_Statement -> return;\n");:}
	| RETURN conditional_expression END                                           					{:compilerOutput.append("Jump_Statement -> return Expression;\n");:}
	; 

/*Iteration Statements*/
iteration_statement ::=   WHILE OPAR conditional_expression CPAR statement                          {:compilerOutput.append("Iteration_Statement -> while ( Expression ) Statement\n");:}
	| WHILE error:e                                                                                 {:parser.report_error("while iteration error",e); :}          
    | FOR OPAR type_specifier ID:id ASSIGN conditional_expression END
      conditional_expression END assignment_expression CPAR statement    							{:compilerOutput.append("Iteration_Statement -> for ( Type_Specifier " +id+ " = conditional_expression; conditional_expression; assignment_expression) Statement \n");:}
    | FOR error:e                                                                                   {:parser.report_error("for iteration error",e); :}          
	;

/*Selection Statements*/
selection_statement ::=   IF OPAR conditional_expression CPAR statement              				{:compilerOutput.append("Selection_Statement -> if ( Expression ) Statement\n");:}      
    | IF OPAR conditional_expression CPAR statement ELSE statement               					{:compilerOutput.append("Selection_Statement -> if ( Expression ) Statement ELSE statement\n");:}
    | IF error:e                                                                                	{:parser.report_error("if selection statement error",e); :}
	| SWITCH OPAR conditional_expression CPAR OCBRA labeled_statement CCBRA                         {:compilerOutput.append("Selection_Statement -> switch ( Expression ) Statement\n");:}
	| SWITCH error:e                                                                                {:parser.report_error("switch selection statement error",e); :} 
    ;

/*Statement List*/
statement_list ::=   statement                                           							{:compilerOutput.append("Statement_List -> Statement\n");:}
	| statement_list statement                                       								{:compilerOutput.append("Statement_List -> Statement_List Statement\n");:}
	;

/*Declaration Lists*/
declaration_list ::=   declaration                                       							{:compilerOutput.append("Declaration_List -> Declaration\n");:}
	| declaration_list declaration                                   	 							{:compilerOutput.append("Declaration_List -> Declaration_List Declaration\n");:}
	;

/*Compound Statements*/
compound_statement ::=   OCBRA CCBRA                                 								{:compilerOutput.append("Compound Statement -> {}\n");:}
	| OCBRA statement_list CCBRA                                     								{:compilerOutput.append("Compound Statement -> { Statement_List }\n");:}
	| OCBRA declaration_list CCBRA                                   								{:compilerOutput.append("Compound Statement -> { Declaration_List }\n");:}
	| OCBRA declaration_list statement_list CCBRA													{:compilerOutput.append("Compound Statement -> { Declaration_List Statement_List }\n");:}
	;

/*Label Statement*/
labeled_statement ::=   CASE conditional_expression COLON statement labeled_statement				{:compilerOutput.append("Labeled_Statement -> case Conditional_Expression: Statement\n");:}
	| DEFAULT COLON statement                                        								{:compilerOutput.append("Labeled_Statement -> default: Statement\n");:}
	| 																								{:compilerOutput.append("Labeled_Statement -> Lambda\n");:}
	;

/*Statement Generalization*/
statement ::=   compound_statement                                            						{:compilerOutput.append("Statement -> Compound_Statement\n");:}
	| expression_statement                                          								{:compilerOutput.append("Statement -> Expression_Statement\n");:}
	| selection_statement 																			{:compilerOutput.append("Statement -> Selection_Statement\n");:}                                      										
	| iteration_statement                                           								{:compilerOutput.append("Statement -> Iteration_Statement\n");:}
	| jump_statement                                                								{:compilerOutput.append("Statement -> Jump_Statement\n");:}
	;

/*Identifier List*/
identifier_list ::=   ID:id                                         								{:compilerOutput.append("Identifier_List -> " + id + "\n");:}
	| identifier_list COMMA ID:id                                   								{:compilerOutput.append("Identifier_List -> Identifier_List, " + id + "\n");:}
	;

/*Parameter List*/
parameter_list ::=   variable_type_specifier ID:id                          						{:compilerOutput.append("Parameter_List -> Variable_Type_Specifier "+id+"\n");:}
	| parameter_list COMMA variable_type_specifier ID:id                    						{:compilerOutput.append("Parameter_List -> Parameter_List , Parameter_Declaration\n");:}
	;

/*Main Declarator*/
main_declarator ::=   MAIN OPAR parameter_list CPAR                 								{:compilerOutput.append("Main_Declarator -> Main ( Parameter_List )\n");:}
    | MAIN OPAR CPAR                                     											{:compilerOutput.append("Main_Declarator -> Main ()\n");:}
    ;

/*Type specifiers*/
type_specifier ::= CHAR                                                 							{:compilerOutput.append("Type_Specifier CHARACTER\n");:}
	| INTEGER                                                       								{:compilerOutput.append("Type_Specifier INTEGER\n");:}
	| DOUBLE                                                        								{:compilerOutput.append("Type_Specifier DOUBLE\n");:}
	| STRING                                                        								{:compilerOutput.append("Type_Specifier STRING\n");:}
    | BOOLEAN                                                       							    {:compilerOutput.append("Type_Specifier BOOLEAN\n");:}
    | VOID                                                          							    {:compilerOutput.append("Type_Specifier VOID\n");:}
	;

/*Variable Type specifiers*/
variable_type_specifier ::= CHAR                                                 					{:compilerOutput.append("Variable_Type_Specifier CHARACTER\n");:}
	| INTEGER                                                       								{:compilerOutput.append("Variable_Type_Specifier INTEGER\n");:}
	| DOUBLE                                                        								{:compilerOutput.append("Variable_Type_Specifier DOUBLE\n");:}
	| STRING                                                        								{:compilerOutput.append("Variable_Type_Specifier STRING\n");:}
    | BOOLEAN                                                       							    {:compilerOutput.append("Variable_Type_Specifier BOOLEAN\n");:}
    ;

/*Variable Declarations*/
declaration ::= type_specifier identifier_list END                                          		{:compilerOutput.append("Declaration -> Type_Specifier Identifier_List\n");:}
	| assignment_expression																			{:compilerOutput.append("Declaration -> Assignment_Expression");:}
	;

/*Assignment Expression*/
assignment_expression ::= type_specifier ID:stringValue ASSIGN conditional_expression END			{:compilerOutput.append("Assigment_Expression -> Type_Specifier " +stringValue+ " = Primary_Expression\n");:}
	| ID:stringValue ASSIGN conditional_expression END                                              {:compilerOutput.append("Assigment_Expression -> " +stringValue+ " = Primary_Expression\n");:}
	;

/*Conditional Expression*/
conditional_expression ::= 	equality_expression														{:compilerOutput.append("Conditional_Expression -> Equality_Expression\n");:}
	| conditional_expression AND equality_expression												{:compilerOutput.append("Conditional_Expression -> Conditional_Expression && Equality_Expression\n");:}
	| conditional_expression OR equality_expression													{:compilerOutput.append("Conditional_Expression -> Conditional_Expression || Equality_Expression\n");:}
	;

equality_expression ::= relational_expression 														{:compilerOutput.append("Equality_Expression -> Relational_Expression\n");:}
	| equality_expression EQU relational_expression          										{:compilerOutput.append("Equality_Expression -> Equality_Expression == Relational_Expression\n");:}
	| equality_expression NEQU relational_expression 												{:compilerOutput.append("Equality_Expression -> Equality_Expression != Relational_Expression\n");:}
	;

/*Relational Expressions*/
relational_expression ::=   additive_expression                         							{:compilerOutput.append("Relational_Expression -> Additive_Expression\n");:} 
	| relational_expression LESS additive_expression                								{:compilerOutput.append("Relational_Expression -> Relational_Expression < Additive_Expression\n");:} 
	| relational_expression GREATER additive_expression             								{:compilerOutput.append("Relational_Expression -> Relational_Expression > Additive_Expression\n");:} 
	| relational_expression LESSEQ additive_expression              								{:compilerOutput.append("Relational_Expression -> Relational_Expression <= Additive_Expression\n");:} 
	| relational_expression GREATEREQ additive_expression           								{:compilerOutput.append("Relational_Expression -> Relational_Expression >= Additive_Expression\n");:} 
	;

/*Additive Expression*/
additive_expression ::=   multiplicative_expression                     							{:compilerOutput.append("Additive_Expression -> Multiplicative_Expression\n");:} 
	| additive_expression ADD multiplicative_expression            									{:compilerOutput.append("Additive_Expression -> Additive_Expression + Multiplicative_Expression\n");:} 
	| additive_expression MIN multiplicative_expression             								{:compilerOutput.append("Additive_Expression -> Additive_Expression - Multiplicative_Expression\n");:} 
	;

/*Multiplicative Expression*/
multiplicative_expression ::=   basic_expression                    								{:compilerOutput.append("Multiplicative_Expression -> Primary Expression\n");:} 
	| multiplicative_expression MUL basic_expression                								{:compilerOutput.append("Multiplicative_Expression -> Multiplicative_Expression * Primary Expression\n");:} 
	| multiplicative_expression DIV basic_expression                								{:compilerOutput.append("Multiplicative_Expression -> Multiplicative_Expression / Primary Expression\n");:}               
	;

/*Basic Expressions*/
basic_expression ::=   primary_expression                             								{:compilerOutput.append("Basic_Expression -> Primary_Expression\n");:}
    |   basic_expression OPAR CPAR                                									{:compilerOutput.append("Basic_Expression -> Basic_Expression ()\n");:}
	|   PRINT OPAR STRINGCONTENT:stringContent CPAR                                             	{:compilerOutput.append("Basic_Expression -> print (\"" +stringContent+ "\")\n");:}
    |   PRINT OPAR STRINGCONTENT:stringContent COMMA identifier_list CPAR              				{:compilerOutput.append("Basic_Expression -> print (\"" +stringContent+ "\", identifier_list)\n");:}
    |   SCAN  OPAR ID:identifierValue CPAR END                                                      {:compilerOutput.append("Basic_Expression -> scan (\"" +identifierValue+ "\")\n");:}
    ;

/*Primary Expression*/
primary_expression ::=  ID:identifierValue                              							{:compilerOutput.append("Primary_Expression -> Identifier: " + identifierValue +"\n"); :}
	|   INT:integerContent                                            								{:compilerOutput.append("Primary_Expression -> Integer: " + integerContent + "\n"); :}
	|   STRINGCONTENT:stringContent                                   								{:compilerOutput.append("Primary_Expression -> String: " + stringContent + "\n"); :}
	|   DOUBLEVALUE:doubleContent                                     								{:compilerOutput.append("Primary_Expression -> Double: " + doubleContent + "\n"); :}
	|   CHARCONTENT:charContent                                       								{:compilerOutput.append("Primary_Expression -> Char: " + charContent + "\n"); :}
	|   TRUE                                            											{:compilerOutput.append("Primary_Expression -> Boolean: True\n");:}
	|   FALSE                                       												{:compilerOutput.append("Primary_Expression -> Boolean: False\n");:}
	;
